from stat import *
import arvados
import datetime
from ._internal import streams as streams
from .api import ThreadSafeAPIClient as ThreadSafeAPIClient
from .arvfile import ArvadosFile as ArvadosFile, ArvadosFileReader as ArvadosFileReader, ArvadosFileWriter as ArvadosFileWriter, NoopLock as NoopLock, WrappableFile as WrappableFile, _FileLikeObjectBase, must_be_writable as must_be_writable, split as split, synchronized as synchronized
from .keep import KeepClient as KeepClient, KeepLocator as KeepLocator
from _typeshed import Incomplete
from arvados.retry import retry_method as retry_method
from collections import deque as deque
from typing import Any, IO, Iterator, Literal, Mapping

ADD: str
DEL: str
MOD: str
TOK: str
FILE: str
COLLECTION: str
ChangeList: Incomplete
ChangeType = Literal[ADD, DEL, MOD, TOK]
CollectionItem: Incomplete
ChangeCallback: Incomplete
CreateType = Literal[COLLECTION, FILE]
Properties = dict[str, Any]
StorageClasses = list[str]

class CollectionBase:
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: types.TracebackType | None) -> None: ...
    def stripped_manifest(self) -> str: ...

class _WriterFile(_FileLikeObjectBase):
    dest: Incomplete
    def __init__(self, coll_writer, name) -> None: ...
    def close(self) -> None: ...
    def write(self, data) -> None: ...
    def writelines(self, seq) -> None: ...
    def flush(self) -> None: ...

class RichCollectionBase(CollectionBase):
    parent: Incomplete
    def __init__(self, parent: Incomplete | None = None) -> None: ...
    def writable(self) -> bool: ...
    def root_collection(self) -> Collection: ...
    def stream_name(self) -> str: ...
    def has_remote_blocks(self) -> bool: ...
    def set_has_remote_blocks(self, val: bool) -> None: ...
    def find_or_create(self, path: str, create_type: CreateType) -> CollectionItem: ...
    def find(self, path: str) -> CollectionItem: ...
    def mkdirs(self, path: str) -> Subcollection: ...
    def open(self, path: str, mode: str = 'r', encoding: str | None = None) -> IO: ...
    def modified(self) -> bool: ...
    def committed(self): ...
    def set_committed(self, value: bool = True): ...
    def __iter__(self) -> Iterator[str]: ...
    def __getitem__(self, k: str) -> CollectionItem: ...
    def __contains__(self, k: str) -> bool: ...
    def __len__(self) -> int: ...
    def __delitem__(self, p: str) -> None: ...
    def keys(self) -> Iterator[str]: ...
    def values(self) -> list[CollectionItem]: ...
    def items(self) -> list[tuple[str, CollectionItem]]: ...
    def exists(self, path: str) -> bool: ...
    def remove(self, path: str, recursive: bool = False) -> None: ...
    def clone(self) -> None: ...
    def add(self, source_obj: CollectionItem, target_name: str, overwrite: bool = False, reparent: bool = False) -> None: ...
    def copy(self, source: str | CollectionItem, target_path: str, source_collection: RichCollectionBase | None = None, overwrite: bool = False) -> None: ...
    def rename(self, source: str | CollectionItem, target_path: str, source_collection: RichCollectionBase | None = None, overwrite: bool = False) -> None: ...
    def portable_manifest_text(self, stream_name: str = '.') -> str: ...
    def manifest_text(self, stream_name: str = '.', strip: bool = False, normalize: bool = False, only_committed: bool = False) -> str: ...
    def diff(self, end_collection: RichCollectionBase, prefix: str = '.', holding_collection: Collection | None = None) -> ChangeList: ...
    def apply(self, changes: ChangeList) -> None: ...
    def portable_data_hash(self) -> str: ...
    def subscribe(self, callback: ChangeCallback) -> None: ...
    def unsubscribe(self) -> None: ...
    def notify(self, event: ChangeType, collection: RichCollectionBase, name: str, item: CollectionItem) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def flush(self) -> None: ...

class Collection(RichCollectionBase):
    replication_desired: Incomplete
    put_threads: Incomplete
    num_retries: Incomplete
    lock: Incomplete
    events: Incomplete
    def __init__(self, manifest_locator_or_text: str | None = None, api_client: arvados.api_resources.ArvadosAPIClient | None = None, keep_client: arvados.keep.KeepClient | None = None, num_retries: int = 10, parent: Collection | None = None, apiconfig: Mapping[str, str] | None = None, block_manager: arvados.arvfile._BlockManager | None = None, replication_desired: int | None = None, storage_classes_desired: list[str] | None = None, put_threads: int | None = None) -> None: ...
    def storage_classes_desired(self) -> list[str]: ...
    def root_collection(self) -> Collection: ...
    def get_properties(self) -> Properties: ...
    def get_trash_at(self) -> datetime.datetime | None: ...
    def stream_name(self) -> str: ...
    def writable(self) -> bool: ...
    def known_past_version(self, modified_at_and_portable_data_hash: tuple[str | None, str | None]) -> bool: ...
    def update(self, other: Collection | None = None, num_retries: int | None = None) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: types.TracebackType | None) -> None: ...
    def stop_threads(self) -> None: ...
    def manifest_locator(self) -> str | None: ...
    def clone(self, new_parent: Collection | None = None, new_name: str | None = None, readonly: bool = False, new_config: Mapping[str, str] | None = None) -> Collection: ...
    def api_response(self) -> dict[str, Any] | None: ...
    def find_or_create(self, path: str, create_type: CreateType) -> CollectionItem: ...
    def find(self, path: str) -> CollectionItem: ...
    def remove(self, path: str, recursive: bool = False) -> None: ...
    def save(self, properties: Properties | None = None, storage_classes: StorageClasses | None = None, trash_at: datetime.datetime | None = None, merge: bool = True, num_retries: int | None = None, preserve_version: bool = False) -> str: ...
    def save_new(self, name: str | None = None, create_collection_record: bool = True, owner_uuid: str | None = None, properties: Properties | None = None, storage_classes: StorageClasses | None = None, trash_at: datetime.datetime | None = None, ensure_unique_name: bool = False, num_retries: int | None = None, preserve_version: bool = False): ...
    def notify(self, event: ChangeType, collection: RichCollectionBase, name: str, item: CollectionItem) -> None: ...

class Subcollection(RichCollectionBase):
    lock: Incomplete
    name: Incomplete
    num_retries: Incomplete
    def __init__(self, parent, name) -> None: ...
    def root_collection(self) -> Collection: ...
    def writable(self) -> bool: ...
    def stream_name(self) -> str: ...
    def clone(self, new_parent: Collection | None = None, new_name: str | None = None) -> Subcollection: ...

class CollectionReader(Collection):
    lock: Incomplete
    def __init__(self, manifest_locator_or_text, *args, **kwargs) -> None: ...
    def writable(self) -> bool: ...
