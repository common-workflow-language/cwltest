from stat import *
import arvados
import arvados.api_resources
import datetime
from .api import ThreadSafeAPIClient as ThreadSafeAPIClient
from .arvfile import ArvadosFile
from .keep import KeepClient
from _typeshed import Incomplete
from collections import deque as deque
from typing import Any, IO, Iterator, Literal, Mapping, Union

CollectionItem = ArvadosFile | RichCollectionBase

class CollectionBase: ...

class RichCollectionBase(CollectionBase):
    def __init__(self, parent: CollectionBase | None = None) -> None: ...
    def writable(self) -> bool: ...
    def root_collection(self) -> Collection: ...
    def stream_name(self) -> str: ...
    def has_remote_blocks(self) -> bool: ...
    def set_has_remote_blocks(self, val: bool) -> None: ...
    def find(self, path: str) -> CollectionItem: ...
    def mkdirs(self, path: str) -> Subcollection: ...
    def open(self, path: str, mode: str = 'r', encoding: str | None = None) -> IO[bytes]: ...
    def __iter__(self) -> Iterator[str]: ...
    def __getitem__(self, k: str) -> CollectionItem: ...
    def __contains__(self, k: str) -> bool: ...
    def __len__(self) -> int: ...
    def __delitem__(self, p: str) -> None: ...
    def keys(self) -> Iterator[str]: ...
    def values(self) -> list[CollectionItem]: ...
    def items(self) -> list[tuple[str, CollectionItem]]: ...
    def exists(self, path: str) -> bool: ...
    def remove(self, path: str, recursive: bool = False) -> None: ...
    def clone(self) -> None: ...
    def add(self, source_obj: CollectionItem, target_name: str, overwrite: bool = False, reparent: bool = False) -> None: ...
    def copy(self, source: str | CollectionItem, target_path: str, source_collection: RichCollectionBase | None = None, overwrite: bool = False) -> None: ...
    def rename(self, source: str | CollectionItem, target_path: str, source_collection: RichCollectionBase | None = None, overwrite: bool = False) -> None: ...
    def portable_manifest_text(self, stream_name: str = '.') -> str: ...
    def manifest_text(self, stream_name: str = '.', strip: bool = False, normalize: bool = False, only_committed: bool = False) -> str: ...
    def portable_data_hash(self) -> str: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def flush(self) -> None: ...

class Collection(RichCollectionBase):
    def __init__(self, manifest_locator_or_text: str | None = None, api_client: arvados.api.ThreadSafeAPIClient | None = None, keep_client: KeepClient | None = None, num_retries: int = 10, parent: Collection | None = None, apiconfig: Mapping[str, str] | None = None, replication_desired: int | None = None, storage_classes_desired: list[str] | None = None, put_threads: int | None = None) -> None: ...
    def storage_classes_desired(self) -> list[str]: ...
    def root_collection(self) -> Collection: ...
    def get_trash_at(self) -> datetime.datetime | None: ...
    def stream_name(self) -> str: ...
    def writable(self) -> bool: ...
    def known_past_version(self, modified_at_and_portable_data_hash: tuple[str | None, str | None]) -> bool: ...
    def update(self, other: Collection | None = None, num_retries: int | None = None) -> None: ...
    def manifest_locator(self) -> str | None: ...
    def api_response(self) -> dict[str, Any] | None: ...
    def find(self, path: str) -> CollectionItem: ...
    def remove(self, path: str, recursive: bool = False) -> None: ...

class Subcollection(RichCollectionBase):
    def __init__(self, parent: CollectionBase, name: str) -> None: ...
    def root_collection(self) -> Collection: ...
    def writable(self) -> bool: ...
    def stream_name(self) -> str: ...

class CollectionReader(Collection):
    def __init__(self, manifest_locator_or_text: str, api_client: arvados.api.ThreadSafeAPIClient | None = None, keep_client: KeepClient | None = None, num_retries: int = 10) -> None: ...
    def writable(self) -> bool: ...
