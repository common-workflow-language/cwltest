from . import config as config
from ._internal import streams as streams
from .errors import ArgumentError as ArgumentError, AssertionError as AssertionError, KeepWriteError as KeepWriteError
from .keep import KeepLocator as KeepLocator
from .retry import retry_method as retry_method
from _typeshed import Incomplete
from collections.abc import Generator

MOD: str
WRITE: str

def split(path): ...

class UnownedBlockError(Exception): ...

class _FileLikeObjectBase:
    name: Incomplete
    mode: Incomplete
    closed: bool
    def __init__(self, name, mode) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: types.TracebackType | None) -> None: ...
    def close(self) -> None: ...

class ArvadosFileReaderBase(_FileLikeObjectBase):
    num_retries: Incomplete
    def __init__(self, name, mode, num_retries: Incomplete | None = None) -> None: ...
    def __iter__(self): ...
    def decompressed_name(self): ...
    def seek(self, pos, whence=...): ...
    def tell(self): ...
    def readable(self): ...
    def writable(self): ...
    def seekable(self): ...
    def readall(self, size=..., num_retries: Incomplete | None = None) -> Generator[Incomplete]: ...
    def readline(self, size=..., num_retries: Incomplete | None = None): ...
    def decompress(self, decompress, size, num_retries: Incomplete | None = None) -> Generator[Incomplete]: ...
    def readall_decompressed(self, size=..., num_retries: Incomplete | None = None): ...
    def readlines(self, sizehint=..., num_retries: Incomplete | None = None): ...
    def size(self) -> None: ...
    def read(self, size, num_retries: Incomplete | None = None) -> None: ...
    def readfrom(self, start, size, num_retries: Incomplete | None = None) -> None: ...

def synchronized(orig_func): ...

class StateChangeError(Exception):
    state: Incomplete
    nextstate: Incomplete
    def __init__(self, message, state, nextstate) -> None: ...

class _BufferBlock:
    WRITABLE: int
    PENDING: int
    COMMITTED: int
    ERROR: int
    DELETED: int
    blockid: Incomplete
    buffer_block: Incomplete
    buffer_view: Incomplete
    write_pointer: int
    owner: Incomplete
    lock: Incomplete
    wait_for_commit: Incomplete
    error: Incomplete
    def __init__(self, blockid, starting_capacity, owner) -> None: ...
    def append(self, data) -> None: ...
    STATE_TRANSITIONS: Incomplete
    def set_state(self, nextstate, val: Incomplete | None = None) -> None: ...
    def state(self): ...
    def size(self): ...
    def locator(self): ...
    def clone(self, new_blockid, owner): ...
    def clear(self) -> None: ...
    def repack_writes(self) -> None: ...

class NoopLock:
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: types.TracebackType | None) -> None: ...
    def acquire(self, blocking: bool = False) -> None: ...
    def release(self) -> None: ...

def must_be_writable(orig_func): ...

class _BlockManager:
    DEFAULT_PUT_THREADS: int
    lock: Incomplete
    prefetch_lookahead: Incomplete
    num_put_threads: Incomplete
    copies: Incomplete
    storage_classes: Incomplete
    threads_lock: Incomplete
    padding_block: Incomplete
    num_retries: Incomplete
    def __init__(self, keep, copies: Incomplete | None = None, put_threads: Incomplete | None = None, num_retries: Incomplete | None = None, storage_classes_func: Incomplete | None = None) -> None: ...
    def alloc_bufferblock(self, blockid: Incomplete | None = None, starting_capacity=..., owner: Incomplete | None = None): ...
    def dup_block(self, block, owner): ...
    def is_bufferblock(self, locator): ...
    def start_put_threads(self) -> None: ...
    def stop_threads(self) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: types.TracebackType | None) -> None: ...
    def repack_small_blocks(self, force: bool = False, sync: bool = False, closed_file_size: int = 0) -> None: ...
    def commit_bufferblock(self, block, sync) -> None: ...
    def get_bufferblock(self, locator): ...
    def get_padding_block(self): ...
    def delete_bufferblock(self, locator) -> None: ...
    def get_block_contents(self, locator, num_retries, cache_only: bool = False): ...
    def commit_all(self) -> None: ...
    def block_prefetch(self, locator) -> None: ...

class ArvadosFile:
    parent: Incomplete
    name: Incomplete
    lock: Incomplete
    def __init__(self, parent, name, stream=[], segments=[]) -> None: ...
    def writable(self): ...
    def permission_expired(self, as_of_dt: Incomplete | None = None): ...
    def has_remote_blocks(self): ...
    def segments(self): ...
    def clone(self, new_parent, new_name): ...
    def replace_contents(self, other) -> None: ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def set_segments(self, segs) -> None: ...
    def set_committed(self, value: bool = True) -> None: ...
    def committed(self): ...
    def add_writer(self, writer) -> None: ...
    def remove_writer(self, writer, flush) -> None: ...
    def closed(self): ...
    def truncate(self, size) -> None: ...
    def readfrom(self, offset, size, num_retries, exact: bool = False, return_memoryview: bool = False): ...
    def writeto(self, offset, data, num_retries): ...
    def flush(self, sync: bool = True, num_retries: int = 0) -> None: ...
    def add_segment(self, blocks, pos, size) -> None: ...
    def size(self): ...
    def manifest_text(self, stream_name: str = '.', portable_locators: bool = False, normalize: bool = False, only_committed: bool = False): ...

class ArvadosFileReader(ArvadosFileReaderBase):
    arvadosfile: Incomplete
    def __init__(self, arvadosfile, mode: str = 'r', num_retries: Incomplete | None = None) -> None: ...
    def size(self): ...
    def stream_name(self): ...
    def readinto(self, b): ...
    def read(self, size: int = -1, num_retries: Incomplete | None = None, return_memoryview: bool = False): ...
    def readfrom(self, offset, size, num_retries: Incomplete | None = None, return_memoryview: bool = False): ...
    def flush(self) -> None: ...

class ArvadosFileWriter(ArvadosFileReader):
    def __init__(self, arvadosfile, mode, num_retries: Incomplete | None = None) -> None: ...
    def writable(self): ...
    def write(self, data, num_retries: Incomplete | None = None): ...
    def writelines(self, seq, num_retries: Incomplete | None = None) -> None: ...
    def truncate(self, size: Incomplete | None = None) -> None: ...
    def flush(self) -> None: ...
    def close(self, flush: bool = True) -> None: ...

class WrappableFile:
    f: Incomplete
    closed: bool
    def __init__(self, f) -> None: ...
    def close(self): ...
    def flush(self): ...
    def read(self, *args, **kwargs): ...
    def readable(self): ...
    def readinto(self, *args, **kwargs): ...
    def seek(self, *args, **kwargs): ...
    def seekable(self): ...
    def tell(self): ...
    def writable(self): ...
    def write(self, *args, **kwargs): ...
