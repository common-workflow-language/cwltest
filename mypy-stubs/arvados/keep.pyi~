import queue
import threading
from ._internal import Timer as Timer, basedirs as basedirs, diskcache as diskcache
from ._internal.pycurl import PyCurlHelper as PyCurlHelper
from _typeshed import Incomplete

global_client_object: Incomplete

class KeepLocator:
    EPOCH_DATETIME: Incomplete
    HINT_RE: Incomplete
    hints: Incomplete
    md5sum: Incomplete
    size: Incomplete
    def __init__(self, locator_str) -> None: ...
    def stripped(self): ...
    perm_sig: Incomplete
    @property
    def perm_expiry(self): ...
    @perm_expiry.setter
    def perm_expiry(self, value) -> None: ...
    def permission_hint(self): ...
    def parse_permission_hint(self, s) -> None: ...
    def permission_expired(self, as_of_dt: Incomplete | None = None): ...

class KeepBlockCache:
    cache_max: Incomplete
    cache_total: int
    def __init__(self, cache_max: int = 0, max_slots: int = 0, disk_cache: bool = False, disk_cache_dir: Incomplete | None = None) -> None: ...
    class _CacheSlot:
        locator: Incomplete
        ready: Incomplete
        content: Incomplete
        def __init__(self, locator) -> None: ...
        def get(self): ...
        def set(self, value): ...
        def size(self): ...
        def evict(self) -> None: ...
    def cap_cache(self) -> None: ...
    def get(self, locator): ...
    def reserve_cache(self, locator): ...
    def set(self, slot, blob) -> None: ...

class _Counter:
    def __init__(self, v: int = 0) -> None: ...
    def add(self, v) -> None: ...
    def get(self): ...

class KeepClient:
    DEFAULT_TIMEOUT: Incomplete
    DEFAULT_PROXY_TIMEOUT: Incomplete
    class _KeepService(PyCurlHelper):
        HTTP_ERRORS: Incomplete
        root: Incomplete
        get_headers: Incomplete
        put_headers: Incomplete
        upload_counter: Incomplete
        download_counter: Incomplete
        insecure: Incomplete
        def __init__(self, root, user_agent_pool=..., upload_counter: Incomplete | None = None, download_counter: Incomplete | None = None, headers={}, insecure: bool = False) -> None: ...
        def usable(self): ...
        def finished(self): ...
        def last_result(self): ...
        def get(self, locator, method: str = 'GET', timeout: Incomplete | None = None): ...
        def put(self, hash_s, body, timeout: Incomplete | None = None, headers={}): ...
    class _KeepWriterQueue(queue.Queue):
        wanted_copies: Incomplete
        wanted_storage_classes: Incomplete
        successful_copies: int
        confirmed_storage_classes: Incomplete
        response: Incomplete
        storage_classes_tracking: bool
        queue_data_lock: Incomplete
        pending_tries: Incomplete
        pending_tries_notification: Incomplete
        def __init__(self, copies, classes=[]) -> None: ...
        def write_success(self, response, replicas_nr, classes_confirmed) -> None: ...
        def write_fail(self, ks) -> None: ...
        def pending_copies(self): ...
        def satisfied_classes(self): ...
        def pending_classes(self): ...
        def get_next_task(self): ...
    class _KeepWriterThreadPool:
        total_task_nr: int
        workers: Incomplete
        queue: Incomplete
        def __init__(self, data, data_hash, copies, max_service_replicas, timeout: Incomplete | None = None, classes=[]) -> None: ...
        def add_task(self, ks, service_root) -> None: ...
        def done(self): ...
        def join(self) -> None: ...
        def response(self): ...
    class _KeepWriterThread(threading.Thread):
        class TaskFailed(RuntimeError): ...
        timeout: Incomplete
        queue: Incomplete
        data: Incomplete
        data_hash: Incomplete
        daemon: bool
        def __init__(self, queue, data, data_hash, timeout: Incomplete | None = None) -> None: ...
        def run(self) -> None: ...
        def do_task(self, service, service_root): ...
    lock: Incomplete
    insecure: Incomplete
    block_cache: Incomplete
    timeout: Incomplete
    proxy_timeout: Incomplete
    upload_counter: Incomplete
    download_counter: Incomplete
    put_counter: Incomplete
    get_counter: Incomplete
    hits_counter: Incomplete
    misses_counter: Incomplete
    num_prefetch_threads: Incomplete
    local_store: Incomplete
    head: Incomplete
    get: Incomplete
    put: Incomplete
    num_retries: Incomplete
    max_replicas_per_service: Incomplete
    api_token: Incomplete
    using_proxy: bool
    api_client: Incomplete
    def __init__(self, api_client: Incomplete | None = None, proxy: Incomplete | None = None, timeout=..., proxy_timeout=..., api_token: Incomplete | None = None, local_store: Incomplete | None = None, block_cache: Incomplete | None = None, num_retries: int = 10, session: Incomplete | None = None, num_prefetch_threads: Incomplete | None = None) -> None: ...
    def current_timeout(self, attempt_number): ...
    def build_services_list(self, force_rebuild: bool = False) -> None: ...
    def weighted_service_roots(self, locator, force_rebuild: bool = False, need_writable: bool = False): ...
    def map_new_services(self, roots_map, locator, force_rebuild, need_writable, headers): ...
    def get_from_cache(self, loc_s): ...
    def refresh_signature(self, loc): ...
    def head(self, loc_s, **kwargs): ...
    def get(self, loc_s, **kwargs): ...
    def put(self, data, copies: int = 2, num_retries: Incomplete | None = None, request_id: Incomplete | None = None, classes: Incomplete | None = None): ...
    def block_prefetch(self, locator) -> None: ...
    def stop_prefetch_threads(self) -> None: ...
    def local_store_put(self, data, copies: int = 1, num_retries: Incomplete | None = None, classes=[]): ...
    def local_store_get(self, loc_s, num_retries: Incomplete | None = None): ...
    def local_store_head(self, loc_s, num_retries: Incomplete | None = None): ...
